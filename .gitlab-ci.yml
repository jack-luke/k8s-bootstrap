stages:
  - build-exec-env
  - install-k3s
  - cleanup-exec-env
  - install-flux

default:
  image: docker:29.1.2-cli-alpine3.23

variables:
  EXEC_ENV_IMAGE: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}/k3s-install-exec-env
  EXEC_ENV_TAG: v0.0.1
  HELM_KUBECTL_IMAGE: dtzar/helm-kubectl:4.0.4
  FLUX_OPERATOR_VERSION: 0.38.1

# Build the Ansible Execution Environment for installing K3s
build-exec-env:
  stage: build-exec-env
  before_script:
    - cd ansible/execution-environment

    # Login to GitLab project registry
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    # if image does not exist in registry, build it 
    - |
      if ! docker pull "$EXEC_ENV_IMAGE:$EXEC_ENV_TAG"; then

        # Install Python, pip and ansible-builder
        apk add --no-cache python3 py3-pip
        pip install --break-system-packages ansible-builder

        # Build execution environment image
        ansible-builder build -t ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG} --container-runtime docker
        
        # Push execution environment image to GitLab registry
        docker push ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}
      
      else 
        echo "Image '$EXEC_ENV_IMAGE:$EXEC_ENV_TAG' exists, skipping..."
      fi

# Install K3s using the Ansible Execution Environment previously built
install-k3s:
  stage: install-k3s
  image: ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}
  variables:
    ANSIBLE_HOST_KEY_CHECKING: "False"
  before_script:
    - cd ansible

    # Base64 decode the Ansible inventory from its CI variable
    - echo "$ANSIBLE_INVENTORY_B64" | base64 -d > inventory.yaml

    # Base64 decode SSH key for the Ansible target host
    - mkdir ~/.ssh
    - echo "$SSH_KEY_B64" | base64 -d > ~/.ssh/id_rsa
    - chmod 0600 ~/.ssh/id_rsa
  script:
    # run k3s-ansible to install K3s
    - ansible-playbook k3s.orchestration.site -i inventory.yaml --user ${ANSIBLE_USER}

    # k3s-ansible will not properly download the kubeconfig to control node, so export it manually
    - ansible-playbook kubeconfig-export.yaml -i inventory.yaml --user ${ANSIBLE_USER}
    
    # edit Kubeconfig permissions to allow Flux image to read it
    - chmod 644 .kube/config
  artifacts:
    access: none # do not permit downloading of the kuebconfig from the project
    paths:
      - ansible/.kube/config

# Remove lingering image from local Docker host
cleanup-exec-env:
  stage: cleanup-exec-env
  script:
    - echo "Removing execution environment image '${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}'..."
    - docker rmi ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}

# Install Flux Operator, a Flux Instance, and Git secret
install-flux:
  stage: install-flux
  image: $HELM_KUBECTL_IMAGE
  before_script:
    - export KUBECONFIG=ansible/.kube/config

    # decode cert to allow Flux to verify GitLab server
    - echo "$GITLAB_CERT_B64" | base64 -d > gitlab.crt
  script:
    # Install Flux Operator
    - helm upgrade flux-operator oci://ghcr.io/controlplaneio-fluxcd/charts/flux-operator
      --install
      --version ${FLUX_OPERATOR_VERSION}
      --namespace flux-system --create-namespace

    # Create a Flux Instance to install controllers and setup Git source
    - kubectl apply -f flux/flux-instance.yaml

    # Create secret to store Git credentials
    - kubectl create secret generic flux-system
      --namespace flux-system
      --from-literal=username=git
      --from-literal=password=${GITLAB_TOKEN}
      --from-file=gitlab.crt=gitlab.crt