stages:
  - build-exec-env
  - install-k3s
  - cleanup-exec-env
  - install-metallb
  - install-flux
  - create-vault-tls-secret

default:
  image: docker:29.2.0-cli-alpine3.23

variables:
  EXEC_ENV_IMAGE: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}/k3s-install-exec-env
  EXEC_ENV_TAG: v0.0.1
  HELM_KUBECTL_IMAGE: dtzar/helm-kubectl:4.0.4
  METALLB_VERSION: 0.15.3
  FLUX_OPERATOR_VERSION: 0.40.0

# Build the Ansible Execution Environment for installing K3s
build-exec-env:
  stage: build-exec-env
  before_script:
    - cd ansible/execution-environment

    # Login to GitLab project registry
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    # if image does not exist in registry, build it 
    - |
      if ! docker pull "$EXEC_ENV_IMAGE:$EXEC_ENV_TAG"; then

        # Install Python, pip and ansible-builder
        apk add --no-cache python3 py3-pip
        pip install --break-system-packages ansible-builder

        # Build execution environment image
        ansible-builder build -t ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG} --container-runtime docker
        
        # Push execution environment image to GitLab registry
        docker push ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}
      
      else 
        echo "Image '$EXEC_ENV_IMAGE:$EXEC_ENV_TAG' exists, skipping..."
      fi

# Install K3s using the Ansible Execution Environment previously built
install-k3s:
  stage: install-k3s
  image: ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}
  variables:
    ANSIBLE_HOST_KEY_CHECKING: "False"
  before_script:
    - cd ansible

    # Base64 decode SSH key for the Ansible target host
    - mkdir ~/.ssh
    - echo "$SSH_KEY_B64" | base64 -d > ~/.ssh/id_rsa
    - chmod 0600 ~/.ssh/id_rsa
  script:
    # run k3s-ansible to install K3s
    - ansible-playbook k3s.orchestration.site -i inventory.yaml --user ${ANSIBLE_USER}

    # k3s-ansible will not properly download the kubeconfig to control node, so export it manually
    - ansible-playbook kubeconfig-export.yaml -i inventory.yaml --user ${ANSIBLE_USER}
  artifacts:
    access: none # do not permit downloading of the kuebconfig from the project
    paths:
      - ansible/.kube/config

# Remove lingering image from local Docker host
cleanup-exec-env:
  stage: cleanup-exec-env
  script:
    - echo "Removing execution environment image '${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}'..."
    - docker rmi ${EXEC_ENV_IMAGE}:${EXEC_ENV_TAG}

# Install MetalLB
install-metallb:
  stage: install-metallb
  image: $HELM_KUBECTL_IMAGE
  before_script:
    - export KUBECONFIG=ansible/.kube/config
  script:
    # Add MetalLB repo
    - helm repo add metallb https://metallb.github.io/metallb
    - helm repo update

    # Install MetalLB
    - helm upgrade metallb metallb/metallb
      --install
      --version ${METALLB_VERSION}
      --namespace metallb-system --create-namespace
      --wait

    # Configure LoadBalancer IPs
    - kubectl apply -f metallb/lb-config.yaml

# Install Flux Operator, a Flux Instance, and Git secret
install-flux:
  stage: install-flux
  image: $HELM_KUBECTL_IMAGE
  before_script:
    - export KUBECONFIG=ansible/.kube/config

    # decode cert to allow Flux to verify GitLab server
    - echo "$GITLAB_CERT_B64" | base64 -d > gitlab.crt
  script:
    # Install Flux Operator
    - helm upgrade flux-operator oci://ghcr.io/controlplaneio-fluxcd/charts/flux-operator
      --install
      --version ${FLUX_OPERATOR_VERSION}
      --namespace flux-system --create-namespace

    # Create a Flux Instance to install controllers and setup Git source
    - kubectl apply -f flux/flux-instance.yaml

    # Create secret to store Git credentials
    - kubectl create secret generic gitlab-credentials
      --namespace flux-system
      --from-literal=username=git
      --from-literal=password=${GITLAB_TOKEN}
      --from-file=ca.crt=gitlab.crt
      --dry-run=client -o yaml | kubectl apply -f -

# Create TLS secret for Vault, from which cluster-wide PKI can be set up
# See: https://cert-manager.io/docs/configuration/vault/#accessing-a-vault-server-with-mtls-enforced
create-vault-tls-secret:
  stage: create-vault-tls-secret
  image: $HELM_KUBECTL_IMAGE
  before_script:
    - export KUBECONFIG=ansible/.kube/config

    # Decode all certs for the TLS secret
    - echo "$VAULT_SERVER_CERT_B64" | base64 -d > vault.crt
    - echo "$VAULT_SERVER_KEY_B64" | base64 -d > vault.key
    - echo "$VAULT_CA_B64" | base64 -d > vault.ca
  script: 
    # Create Vault namespace if it does not exist
    - kubectl create namespace vault 
      --dry-run=client -o yaml | kubectl apply -f -

    # Create Vault TLS server secret
    - kubectl create secret generic vault-server-tls
      --namespace vault
      --from-file=vault.crt=vault.crt
      --from-file=vault.key=vault.key
      --from-file=vault.ca=vault.ca
      --dry-run=client -o yaml | kubectl apply -f -

    # Create CA secret for Vault Secrets Operator to verify Vault server
    - kubectl create secret generic vault-server-ca
      --namespace vault
      --from-file=ca.crt=vault.ca
      --dry-run=client -o yaml | kubectl apply -f -